#[macro_use]
extern crate error_chain;

mod errors {
    error_chain! {
        errors {
            DomainFailed {}
        }
    }
}

use errors::*;

pub trait VariableBase {
    type Value;
    type DomainEvent;
}

pub trait FiniteDomain: VariableBase {
    type Possibilities: Iterator<Item = <Self as VariableBase>::Value>;

    fn contains(&self, value: &<Self as VariableBase>::Value) -> bool;
    fn possibilities(&self) -> Self::Possibilities;
}

pub trait Instantiable: VariableBase {
    fn instantiate(&mut self, value: &<Self as VariableBase>::Value) -> Result<<Self as VariableBase>::DomainEvent>;
}

pub trait Removeable: VariableBase {
    fn remove(&mut self, value: &<Self as VariableBase>::Value) -> Result<<Self as VariableBase>::DomainEvent>;
}

pub trait Bounded: VariableBase {
    fn lower_bound(&self) -> &<Self as VariableBase>::Value;
    fn upper_bound(&self) -> &<Self as VariableBase>::Value;
    fn update_lower_bound(&mut self, value: &<Self as VariableBase>::Value) -> Result<<Self as VariableBase>::DomainEvent>;
    fn update_upper_bound(&mut self, value: &<Self as VariableBase>::Value)
        ->Result<<Self as VariableBase>::DomainEvent>;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
    }
}
